""" 
The frontend was generated by the tool Tkinter Designer by Parth Jadhav
The tool will convert your design in figma to python code
https://github.com/ParthJadhav/Tkinter-Designer
"""
from pathlib import Path
from collections import defaultdict
from tkinter import *
from queue import PriorityQueue

import csv
import sys
import os

maxInt = sys.maxsize

while True:
    """
    fix field larger than field limit 
    https://stackoverflow.com/questions/15063936/csv-error-field-larger-than-field-limit-131072
    """
    try:
        csv.field_size_limit(maxInt)
        break
    except OverflowError:
        maxInt = int(maxInt/10)

def resource_path(relative_path):
    """ 
    Get absolute path to resource, works for dev and for PyInstaller 
    https://stackoverflow.com/questions/7674790/bundling-data-files-with-pyinstaller-onefile
    
    Args:
    relative_path(Any): the sort path direct a file.
    
    Return: 
    The full path direct a file
    """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS2
        base_path = sys._MEIPASS2
    except Exception:
        base_path = os.path.abspath(".")

    return os.path.join(base_path, relative_path)

# BackEnd
class TrieNode(object):
    """
    The class create a Trie node.
    """
    def __init__(self):
        self.meaning = None
        self.children = defaultdict(TrieNode)
class Trie(object):
    """
    A Trie (prefix tree) data structure for efficient word insertion, search, and prefix matching.

    Attributes:
        root (TrieNode): The root node of the Trie.

    Methods:
        insert(word: str, meaning: Any) -> None:
            Inserts a word into the Trie along with its associated meaning.
        search(word: str) -> Any:
            Searches for a word in the Trie and returns its meaning if found, else None.
        find_word(prefix: str) -> List[str]:
            Finds all words in the Trie that start with the given prefix.
    """
    def __init__(self):
        """
        Initializes an empty Trie with a root node.
        """
        self.root = TrieNode()

    def insert(self, word, meaning):
        """
        Inserts a word into the Trie along with its associated meaning.

        Args:
            word (str): The word to insert.
            meaning (Any): The meaning or value associated with the word.
        """
        node = self.root
        for char in word:
            node = node.children[char]
        node.meaning = meaning
    def search(self, word):
        """
        Searches for a word in the Trie and returns its meaning if found, else None.

        Args:
            word (str): The word to search for.

        Returns:
            Any: The meaning associated with the word, or None if not found.
        """
        node = self.root
        for char in word:
            if char not in node.children:
                return None
            node = node.children[char]
        return node.meaning
    def another_search(self, prefix, node, word_list):
        if len(word_list) >= 5:
            return
        if node.meaning != None:
            word_list.append(prefix)
        for letter, child_node in node.children.items():
            self.another_search(prefix + letter, child_node, word_list)
    def find_word(self, prefix):
        """
        Finds all words in the Trie that start with the given prefix.

        Args:
            prefix (str): The prefix to search for.

        Returns:
            List[str]: A list of words starting with the specified prefix.
        """
        node = self.root
        for letter in prefix:
            if letter not in node.children:
                return []
            node = node.children[letter]
        word_list = []
        self.another_search(prefix, node, word_list)
        return word_list


q = PriorityQueue()
trie = Trie()

with open(resource_path(r"assets\Data\dictionary.csv"), mode='r') as file:
    """
    Load word-meaning pairs from a CSV file into a Trie data structure.
    """
    csv_reader = csv.reader(file)
    
    # Iterate over each row in the CSV file
    for row in csv_reader:
        trie.insert(row[0].lower(), row[2])

with open(resource_path(r"assets\Data\flashcard.csv"), mode="r") as file:
    """
    Load level-word-meaning tuple from a CSV file into a priority queue.
    """
    csv_reader = csv.reader(file)
    for row in csv_reader:
        if len(row) >= 2:
            level, word, definition = row[0], row[1], row[2]
            q.put((level, word, definition))

def save_flashcard():
    """
    The function will save the words and meaning from the priority queue into a CSV file before close the window.
    
    Args:
        None
    """
    if word_card != ("1", "Not Found", "Not Found") and word_card != None:
        q.put(word_card)
    flashcard_save = []
    while not q.empty():
        flashcard_save.append(q.get())
    if len(flashcard_save) > 0:
        with open(resource_path(r'assets\Data\flashcard.csv'), 'w', encoding='UTF8', newline='') as f:
            writer = csv.writer(f)
            for card in flashcard_save:
                writer.writerow(card)
    window.destroy()

def on_entry_click(event):
    """
    The function create a placeholer into the textbox with content is "Enter English Word".
    """
    if entry_1.get() == "Enter English Word":
      entry_1.delete(0, END)
      entry_1.configure(foreground="black")

def on_focus_out(event):
    """
    The function keep content of the placeholder into the textbox will press mouse out the textbox.
    """
    if entry_1.get() == "":
      entry_1.insert(0, "Enter English Word")
      entry_1.configure(foreground="white")
        
def check_key(event, entry, master):
    """
    The function will check key release in textbox and suggest up to 5 word
    
    Args:
        entry(any): the parameter is textbox entry_1
        master(any): The parameter is a frame hold listbox.
    
    Return: 
        None
     
    """
    global listbox
    if listbox:
        listbox.destroy()
    if entry.get() == '':
        listbox.destroy()
    if event.keysym == "Return":
        search_defination(event)
        return
    listbox = Listbox(master, bd=0, bg="white", font=("Itim", 18*-1))
    listbox.place(x=40, y=120, width=304.0, height=70)
    
    word = entry.get()
    word_list = trie.find_word(word)

    if len(word_list) > 0:
        for suggestion in word_list:
            if suggestion.lower().startswith(word.lower()):
                listbox.insert(END, suggestion)

    if listbox.size() == 0:
        listbox.destroy()
    listbox.bind("<<ListboxSelect>>", lambda event: on_select(event, entry))


def on_select(event, entry):
    """
    The function will insert the word you click on the listbox into the textbox entry_1.
    The function was called by the check_key function.
    
    Args:
        entry(any): the textbox entry_1
    
    Return:
        None
    
    """
    global listbox
    if not listbox.curselection():
        listbox.destroy()
    value = listbox.get(listbox.curselection())
    entry.delete(0, END)
    entry.insert(0, value)
    listbox.destroy()

def add_word_to_flashcard(word, meaning):
    """
    The function add the word and meaning it's into the priority queue when click on the button_add.
    
    Args:
        word(string): the word you want insert into the priority queue.
        meaning: mean of the word you want insert into the priority queue.
    
    Return:
        None
    """
    global button_add
    q.put(("1", word, meaning))
    button_add.config(state=DISABLED)

def search_defination(event):
    """
    The fucntion will search defination of the word in textbox entry_1 when click on the search button.
    
    Args: 
        None
    
    Return: 
    mean of the word you are looking up or the frame with contain is "not found" will pop up to screen if the word is not in database.
    """
    global listbox, text_output, maincavas, output_fm, button_add
    if listbox:
        listbox.destroy()
        listbox = None
    word = entry_1.get().lower()
    definition = trie.search(word)
    
    if definition == None:
        if text_output:
            text_output.destroy()
        maincavas = Canvas(output_fm, bg="white", bd = False, width=344.0, height=420.0)
        maincavas.place(x=0, y=0)
        maincavas.create_image(175, 200, image=not_found) # make the frame pop up picture not found on screen
    else:
        definitions = definition.split(";")
        if maincavas:
            maincavas.destroy()
        word_textbox = Text(
            output_fm,
            bd = 0,
            bg = "white",
            height=10,
            state=DISABLED,
            font=("Itim", 15),
            wrap=WORD
        ) 
        word_textbox.place(
            x = 0,
            y = 7,
            width=200.0,
            height=40
        )
        word_textbox.configure(state='normal')
        word_textbox.delete('1.0', END)
        word_textbox.insert(END, word)
        word_textbox.configure(state='disabled')
        text_output = Text(
            output_fm,
            bd=0,
            bg="white",
            height=10,
            state=DISABLED,
            font=('Itim', 15),
            wrap=WORD
        )
        text_output.place(
            x=0,
            y=50,
            width=344.0,
            height=330
        )
        text_output.configure(state='normal')
        text_output.delete('1.0', END)
        for text in definitions:
            text_output.insert(END, f"- {text}\n")
        text_output.configure(state='disabled')
        # make the button_add to add the word into the flashcard.
        button_add = Button(
            output_fm,
            bg="white",
            image=button_add_image,
            borderwidth=0,
            highlightthickness=0,
            command=lambda: add_word_to_flashcard(word, definition),    
            relief="flat"
        )
        button_add.place(x=220, y=7)

def button_3_press():
    """
    Creates a flashcard frame and displays the first word when transitioning to the flashcard screen.

    Args:
        None
    
    Returns:
        None
    """
    global output_fm, output_fm_2, flashcard_textbox, word_card
    if output_fm:
        output_fm.destroy()
        output_fm = None
    if output_fm_2 == None:
        output_fm_2 = Frame(window, bg="white")
        output_fm_2.configure(width=344.0, height=370.0)
        output_fm_2.place(x = 18.0, y=80.0)
    flashcard_textbox = Text(
        output_fm_2,
        bd=0,
        bg="white",
        height=10,
        state=DISABLED,
        font=('Itim', 25),
        wrap=WORD
    )
    flashcard_textbox.place(x=100, y=130, width=300, height=300)
    flashcard_textbox.configure(state='normal')
    flashcard_textbox.delete('1.0', END)
    if q.empty():
        word_card = ("1", "Not Found", "Not Found")
    else:
        word_card = q.get()
    flashcard_textbox.insert(END,word_card[1])
    flashcard_textbox.configure(state='disabled')

def button_2_press():
    """
    Creates a new frame to save the meaning of a word.

    Args:
        None
    
    Retrun:
        None
    """
    global output_fm, output_fm_2
    if output_fm_2:
        output_fm_2.destroy()
        output_fm_2 = None
    if output_fm == None:
        output_fm = Frame(window, bg="white")
        output_fm.configure(width=344.0, height=440.0)
        output_fm.place(x = 18.0, y=121.0)

def press_flip(word, meaning):
    """
    Toggles between displaying the word and its meaning in a graphical interface.

    Args:
        word (str): The word to display.
        meaning (str): The meaning of the word (semicolon-separated if multiple meanings).
    Return:
        None
    """
    global flashcard_textbox, meanflashcard_textbox

    # Toggle between word and meaning
    if flashcard_textbox:
        flashcard_textbox.destroy()
        flashcard_textbox = None
        if meanflashcard_textbox is None:
            # Display the meaning
            meanflashcard_textbox = Text(
                output_fm_2,
                bd=0,
                bg="white",
                height=10,
                state=DISABLED,
                font=('Itim', 15),
                wrap=WORD
            )
            meanflashcard_textbox.place(x=18, y=20, width=300, height=300)
            meaning = meaning.split(";")
            meanflashcard_textbox.configure(state='normal')
            meanflashcard_textbox.delete("1.0", END)
            for text in meaning:
                meanflashcard_textbox.insert(END, f"- {text}\n")
            meanflashcard_textbox.configure(state='disabled')

    elif meanflashcard_textbox:
        meanflashcard_textbox.destroy()
        meanflashcard_textbox = None
        if flashcard_textbox is None:
            # Display the word
            flashcard_textbox = Text(
                output_fm_2,
                bd=0,
                bg="white",
                height=10,
                state=DISABLED,
                font=('Itim', 25),
                wrap=WORD
            )
            flashcard_textbox.place(x=100, y=130, width=300, height=300)
            flashcard_textbox.configure(state='normal')
            flashcard_textbox.delete('1.0', END)
            flashcard_textbox.insert('1.0', word)  # Insert the word at the beginning
            flashcard_textbox.configure(state='disabled')

def make_next_word():
    """
    Retrieves the next word from a queue and displays it in a graphical interface.
    
    Args:
        None
    
    Return:
        None
    
    """
    global meanflashcard_textbox, flashcard_textbox, word_card
    if q.empty():
        word_card = ("1", "Not Found", "Not Found")
    else:
        word_card = q.get()
    if flashcard_textbox is None:
        meanflashcard_textbox.destroy()
        meanflashcard_textbox = None
        flashcard_textbox = Text(
                output_fm_2,
                bd=0,
                bg="white",
                height=10,
                state=DISABLED,
                font=('Itim', 25),
                wrap=WORD
            )
        flashcard_textbox.place(x=100, y=130, width=300, height=300)
        flashcard_textbox.configure(state='normal')
        flashcard_textbox.delete('1.0', END)
        flashcard_textbox.insert('1.0', word_card[1])  
        flashcard_textbox.configure(state='disabled')
    else:
        flashcard_textbox.config(state="normal")
        flashcard_textbox.configure(state='normal')
        flashcard_textbox.delete('1.0', END)
        flashcard_textbox.insert('1.0', word_card[1])  
        flashcard_textbox.configure(state='disabled')
        
def press_nextbutton(level, word, meaning):
    """
    Adds a word to the queue and triggers the display of the next word.

    Args:
        level (str): The level of the word.
        word (str): The word to display.
        meaning (str): The meaning of the word.
    
    Return:
        None
    """
    q.put((level, word, meaning))
    make_next_word()

#FrontEnd

#Make window
window = Tk()
window.geometry("380x650")
window.title("Meow Dictionary")
iconpath = os.path.abspath(resource_path(r"favicon.ico"))
window.iconbitmap(iconpath)
window.protocol("WM_DELETE_WINDOW", save_flashcard)

text_output = None
word_textbox = None
maincavas = None
output_fm = None
output_fm_2 = None
not_found = None
button_add = None
flashcard_textbox = None
meanflashcard_textbox = None
word_card = None

# Build A App Name
canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 650,
    width = 380,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
canvas.create_text(
    68.0,
    20.0,
    anchor="nw",
    text="Moew Dictionary ",
    fill="#000000",
    font=("Itim", 20 * -1)
)

image_image_1 = PhotoImage(
    file=resource_path(r"assets\frame0\image_1.png"))
image_1 = canvas.create_image(
    35.0,
    33.0,
    image=image_image_1
)

# Entry Textbox

entry_image_1 = PhotoImage(
    file=resource_path(r"assets\frame0\entry_1.png"))
entry_bg_1 = canvas.create_image(
    190.0,
    100.0,
    image=entry_image_1
)
entry_1 = Entry(
    bd=0,
    bg="white",   
    fg="#949494",
    font=('Itim', 18 * -1),
    highlightthickness=0
)
entry_1.place(
    x=38.0,
    y=81.0,
    width=304.0,
    height=38.0
)
listbox = None
entry_1.insert(0, "Enter English Word")
# Placeholder insert into Entry
entry_1.bind("<FocusIn>", on_entry_click)
entry_1.bind("<FocusOut>", listbox.destroy() if listbox else on_focus_out)
entry_1.bind('<KeyRelease>', lambda event: check_key(event, entry_1, window))
entry_1.bind('<Return>', lambda event: check_key(event, entry_1, window))

button_image_1 = PhotoImage(
    file=resource_path(r"assets\frame0\button_1.png"))
button_1 = Button(
    bg="white",
    image=button_image_1,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: search_defination(None),
    relief="flat"
)
button_1.place(
    x=313.0,
    y=87.0,
    width=33.0,
    height=27.0
)

canvas.create_rectangle(
    0.0,
    556.0,
    380.0,
    648.0,
    fill="white",
    outline="")

canvas.create_rectangle(
    0.0,
    560.0,
    380.0,
    650.0,
    fill="#FFFFFF",
    outline="")

button_image_2 = PhotoImage(
    file=resource_path(r"assets\frame0\button_2.png"))
button_2 = Button(
    bg="#FFFFFF",
    image=button_image_2,
    borderwidth=0,
    bd=0,
    fg="#158aff",
    highlightthickness=0,
    command=button_2_press,  
    relief="flat"
)

button_2.place(
    x=257.0,
    y=575.0,
    width=67.0,
    height=66.0
)

button_image_3 = PhotoImage(
    file=resource_path(r"assets\frame0\button_3.png"))
button_3 = Button(
    bg="#FFFFFF",
    image=button_image_3,
    borderwidth=0,
    highlightthickness=0,
    command=button_3_press,
    relief="flat"
)
button_3.place(
    x=47.0,
    y=570.0,
    width=92.0,
    height=71.0
)

function_fm = Frame(window, bg = "white")
function_fm.configure(width=344.0, height=90.0)
function_fm.place(x = 18.0, y = 50.0 + 410.0)

button_hard_image = PhotoImage(
    file=resource_path(r"assets\frame0\button_Hard.png")
)
button_hard = Button(
    function_fm,
    bg = "white",
    image=button_hard_image,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: press_nextbutton("1", word_card[1], word_card[2]),
    relief="flat"
)
button_hard.place(
    x=0,
    y=60
)

button_good_image = PhotoImage(
    file=resource_path(r"assets\frame0\button_Good.png")
)
button_good = Button(
    function_fm,
    bg="white",
    image=button_good_image,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: press_nextbutton("2", word_card[1], word_card[2]),
    relief="flat"
)
button_good.place(
    x=120.0,
    y=60
)

button_easy_image = PhotoImage(
    file = resource_path(r"assets\frame0\button_Easy.png")
)
button_easy = Button(
    function_fm,
    bg="white",
    image=button_easy_image,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: make_next_word(),
    relief="flat"
)
button_easy.place(
    x=240.0,
    y=60
)

button_flip_image = PhotoImage(
    file = resource_path(r"assets\frame0\flip.png")
)

button_flip = Button(
    function_fm,
    bg="white",
    image=button_flip_image,
    borderwidth=0,
    highlightthickness=0,
    command=lambda: press_flip(word_card[1], word_card[2]),
    relief="flat"
)
button_flip.place(x=145, y=0)
### make output frame

not_found = PhotoImage(
    file=resource_path(r"assets\frame0\image_2.png"))

output_fm = Frame(window, bg="white")
output_fm.configure(width=344.0, height=440.0)
output_fm.place(x = 18.0, y=121.0)

button_add_image = PhotoImage(
    file = resource_path(r"assets\frame0\Add.png")
)

window.resizable(False, False)
window.mainloop()
